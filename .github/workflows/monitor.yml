# 工作流的名称
name: Monitor Good First Issues

# 触发工作流的条件
on:
  # 1. 定时触发：使用 cron 语法，'0 * * * *' 表示每小时的第0分钟运行一次。
  schedule:
    - cron: '0 * * * *'
  # 2. 手动触发：允许你从 Actions 页面手动运行这个工作流，方便测试。
  workflow_dispatch:

# 工作流执行的任务
jobs:
  # 任务的ID
  check-for-issues:
    # 任务运行的环境
    runs-on: ubuntu-latest

    # --- 矩阵策略 ---
    # 为矩阵中列出的每个仓库都运行一次此任务
    strategy:
      matrix:
        # 在这里列出你要监控的所有项目，格式为 'owner/repo'
        repo: ['sigp/lighthouse', 'paradigmxyz/reth']
      # 如果一个任务失败，不取消其他正在运行的任务
      fail-fast: false

    # 任务包含的步骤
    steps:
      # 步骤1：获取最新的代码
      - name: Checkout repository
        uses: actions/checkout@v4

      # 步骤2：使用 GitHub API 检查新 Issue
      - name: Check for new issues with specified labels
        id: issue_check # 给这个步骤一个ID，方便后面引用它的输出
        uses: actions/github-script@v7
        with:
          # GitHub 会自动创建一个令牌，用于API认证
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // --- 在这里配置你要监控的标签 ---
            const LABELS_TO_CHECK = ['good first issue', 'help wanted', 'docs'];
            // --------------------------------

            // 从矩阵中获取当前正在检查的项目名，例如 'kubernetes/kubernetes'
            const repoPath = '${{ matrix.repo }}';
            const [owner, repo] = repoPath.split('/');
            
            console.log(`正在检查项目: ${owner}/${repo}`);
            console.log(`监控的标签: ${LABELS_TO_CHECK.join(', ')}`);

            // 计算一小时前的时间戳
            const oneHourAgo = new Date(Date.now() - 3600 * 1000).toISOString();

            // 使用 GitHub API 搜索 Issue
            // API 需要一个逗号分隔的标签字符串
            const issues = await github.rest.issues.listForRepo({
              owner: owner,
              repo: repo,
              labels: LABELS_TO_CHECK.join(','), // 将标签数组转换为字符串
              state: 'open',
              since: oneHourAgo,
            });

            let foundIssues = [];
            for (const issue of issues.data) {
              // 确保 Issue 是在一小时内“创建”的，而不是仅仅被更新
              if (new Date(issue.created_at) > new Date(Date.now() - 3600 * 1000)) {
                foundIssues.push(issue);
              }
            }

            // 如果找到了符合条件的 Issue
            if (foundIssues.length > 0) {
              console.log(`在 ${owner}/${repo} 中找到了 ${foundIssues.length} 个新 Issue!`);
              let issueList = `在项目 **${owner}/${repo}** 中发现以下新 Issue:\n\n`;
              for (const issue of foundIssues) {
                console.log(`- ${issue.title}: ${issue.html_url}`);
                issueList += `- **${issue.title}**\n  链接: ${issue.html_url}\n\n`;
              }
              // 设置输出变量，给下一个步骤使用
              core.setOutput('found_issues', 'true');
              core.setOutput('issue_list', issueList);
              core.setOutput('email_subject', `发现新的可贡献 Issue 在 ${owner}/${repo}`);
            } else {
              console.log(`在 ${owner}/${repo} 的过去一小时内没有找到新 Issue。`);
              core.setOutput('found_issues', 'false');
            }

      # 步骤3：如果找到了 Issue，就发送邮件通知
      - name: Send notification email
        # 仅当上一步的输出 found_issues 为 'true' 时才运行此步骤
        if: steps.issue_check.outputs.found_issues == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          # 邮件服务器配置
          server_address: smtp.gmail.com
          server_port: 465
          
          # 你的邮箱账户和密码（从 Secrets 中读取）
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          
          # 邮件内容
          subject: ${{ steps.issue_check.outputs.email_subject }} # 使用动态的邮件主题
          to: ${{ secrets.MAIL_USERNAME }}
          from: GitHub Actions Monitor <${{ secrets.MAIL_USERNAME }}>
          body: ${{ steps.issue_check.outputs.issue_list }}
